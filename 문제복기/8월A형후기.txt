1. 둑 쌓아서 마을 침수 안되는 가장 많은 강우량 구하기

-> 우선, 둑이 들어설 수 있는 위치들을 확인하고,
그 중 1개 또는 2개를 뽑아서 정함.
그렇게 둑이 들어간 모든 맵의 경우의 수를 먼저 두고,
각 맵에서 dfs를 돌면서 맵당 최대강우량을 계산해서
그중 최대를 답으로 하면 됨.

구현하면서 주의할 점은
우선 둑이 1개 또는 2개라는 처리를 하는 데 있어서
dookable의 갯수로 이중 포문을 돌리는 대신,
k=1일 경우 k1!=k2일 때를 걸러버리고
k=2일 경우 k1=k2일 때도 자연스럽게 존재해 둑이 1개 또는 2개일 경우를 모두 커버할 수 있도록 하는 것이 있었다.
dfs에서는,
dfs를 돌면서 많은 조건(벽, 둑, 강물이 번지거나 안번짐)이 있었으므로 코드가 매우 복잡했고,
격자형태의 그래프라 인접행렬 필요없이 그냥 i-1,j 등 4방향에 재귀로 dfs를 돌리는 형태로 했다.(둑이나 벽인 경우는 못가고!)
그리고 중요한 점으로! dfs는 강물에 대해서만 진행되어야 한다. 잠기지 않은 곳은 괜히 visited만 true로 바꾸게 되어 실제 강물이 번져야 할 때 visit을 못하게 되므로, 처음 dfs를 소환할 때, 그리고 재귀로 소환할 때 모두 if (!visited && watered) 와 같이 두개의 조건이 모두 만족될 때만 dfs를 돌려야 한다.

2. 마법사, 결계, 공간왜곡 문제
마법을 이용해 n*n 공간을 가로지르는 최소 비용을 구한다.
마법은 최대 k(<=5)가지까지 주어지며, 중복해서 쓸 수는 없고 순서대로 써야 한다.

-> next-permutation을 이용해 12345(k가 최대 5이므로)를 모든 경우의 수로 돌리고, 그중 하나씩 적용될 때마다 최소값을 비교한다.
(ex. 31524의 경우 3,31,315,3152,31524일 때 모두 최소값을 계산해보는 방식.)
이렇게 비교하면 5!+5*4!+10*3!+10*2!+5*1!+1 가지의 모든 경우를 커버할 수 있다.
수가 커져도 이 방법을 사용할 수 있을지는 잘 모르겠다..

공간 왜곡을 구현하는 것이 포인트.
크기가 1일 경우 둘러싸고 있는 8개의 값을 왼쪽 위부터 우우하하좌좌상상 방식으로 순서대로 저장하고, 왜곡이 일어난 경우는 8번째 값이 pop되고 제일 앞으로 왔을 때의 수열을 다시 왼쪽 위부터 우우하하좌좌상상에 덮어씌우는 방식. 크기가 n일 경우는 2*n + .. + 2*n 해서 총 8*n개의 수열을 이용. 이렇게 1~n에 대해 반복문을 돌려 n개의 레이어에 대해 공간 왜곡을 실현.