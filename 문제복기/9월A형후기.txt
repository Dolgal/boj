1. 마을 나누기 문제
인접행렬이 주어진 N개의 마을을 2개로 나눠서 유권자 수 차이가 최소가 되게 하는 문제.
-N개의 마을을 2개로 나누는 것은 00...00 ~ 01...11 까지의 비트를 이용해서 모든 경우를 비교 가능. 1<<(n-1)-1 인 이유는 0000 = 1111, 0110 = 1001 와 같이 같은 분류로 구분한 경우를 고려하면 마지막 마을을 0으로 고정하고, 나머지 마을들을 분류하는것이 효율적이므로!
-dfs의 경우 모든 비트에 대해 if (same region && not visited) dfs를 실시하여 다음 노드로 건너가는 식으로 같은 지역의 마을로만 넘어가게 짠다.
-그 다음, 모든 마을에 대해 if (not visited) dfs를 실시하되, 이 구문이 실행된 횟수를 count하여 2회를 초과한다면 한 지역 이상이 한번에 모든 마을을 탐색하지 못했다는 뜻이므로 지역을 올바르게 나누지 못한 결과로 판단하여 continue 한다.
-만약 dfs(1지역 첫번째); dfs(2지역 첫번째); 와 같이 짜려고 하면 00..00의 경우를 int min의 초기값으로 설정하면 00..01~01...11 까지 탐색하면서 두 지역에 적어도 하나씩 마을이 배정되어 위와 같은 구현방식이 가능하게 된다.

2. 다리 놓기 문제
-섬 별로 구분 / boundary 파악 -> 각 섬간 거리 구해서 인접행렬 생성 -> MST 구하기
-섬별로 구분하는 것은 쉬움. dfs를 돌며 component를 1씩 더하고, 그 때의 component 값을 map에 새기면 map에서도 섬에 번호가 매겨진 것을 쉽게 볼 수 있음.
-boundary 파악도 dfs를 돌며 파악하는데, struct bound{u, l, d, r}로 두고 초기화시킨 다음, dfs를 돌면서 현재 바운더리를 넘는 섬 좌표가 있다면 바운더리를 갱신하는 방식으로 섬 바운더리를 저장!
-섬간 거리의 경우 바운더리를 이용해 비교를 해야 하는데, 섬간 위치에 따라 가로다리 / 세로다리 / 다리불가 의 3종류로 나뉜다. 다리불가의 경우 INF 또는 0(prim)으로 두고, 다리를 놓을 수 있는 경우는 가로/세로 두 다리 놓기가 가능한 경우는 없으므로 가로 먼저 보고, 안된다면 세로로 보는 식으로 짜도 된다. if (u1<=d2 && d2>ud1) 에서 1이 왼쪽이면 cost = l2-r1-1. 1이 오른쪽이면 l1-r2-1. 이런 식으로 cost[i_num][i_num]을 모두 만듦.
-MST는 프림을 이용해서 급하게 참고해서 짰는데.. 첫 2개 테케 말고는 답이 나오는걸 못봤다...